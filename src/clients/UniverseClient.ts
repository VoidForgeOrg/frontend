//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class EntityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getEntity(id: string): Promise<Entity> {
        let url_ = this.baseUrl + "/api/Entity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<Entity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entity>(null as any);
    }

    getEntities(nameContains: string | null | undefined, solarSystemId: string | null | undefined, entityType: EntityType | null | undefined, paging: EntityPaging | null | undefined): Promise<PagedListOfEntity> {
        let url_ = this.baseUrl + "/api/Entity?";
        if (nameContains !== undefined && nameContains !== null)
            url_ += "NameContains=" + encodeURIComponent("" + nameContains) + "&";
        if (solarSystemId !== undefined && solarSystemId !== null)
            url_ += "SolarSystemId=" + encodeURIComponent("" + solarSystemId) + "&";
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Pagination": paging !== undefined && paging !== null ? "" + paging : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagedListOfEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedListOfEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedListOfEntity>(null as any);
    }
}

export class GalaxyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    createGalaxy(galaxyName: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Galaxy?";
        if (galaxyName === null)
            throw new Error("The parameter 'galaxyName' cannot be null.");
        else if (galaxyName !== undefined)
            url_ += "galaxyName=" + encodeURIComponent("" + galaxyName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateGalaxy(_response);
        });
    }

    protected processCreateGalaxy(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getGalaxy(id: string): Promise<Galaxy> {
        let url_ = this.baseUrl + "/api/Galaxy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGalaxy(_response);
        });
    }

    protected processGetGalaxy(response: Response): Promise<Galaxy> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Galaxy.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Galaxy>(null as any);
    }
}

export class SegmentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getSegment(id: string): Promise<Segment> {
        let url_ = this.baseUrl + "/api/Segment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSegment(_response);
        });
    }

    protected processGetSegment(response: Response): Promise<Segment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Segment.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Segment>(null as any);
    }

    getSegments(nameContains: string | null | undefined, descriptionContains: string | null | undefined, galaxyId: string | null | undefined, solarSystemIds: string[] | null | undefined, paging: SegmentPaging | null | undefined): Promise<PagedListOfSegment> {
        let url_ = this.baseUrl + "/api/Segment?";
        if (nameContains !== undefined && nameContains !== null)
            url_ += "NameContains=" + encodeURIComponent("" + nameContains) + "&";
        if (descriptionContains !== undefined && descriptionContains !== null)
            url_ += "DescriptionContains=" + encodeURIComponent("" + descriptionContains) + "&";
        if (galaxyId !== undefined && galaxyId !== null)
            url_ += "GalaxyId=" + encodeURIComponent("" + galaxyId) + "&";
        if (solarSystemIds !== undefined && solarSystemIds !== null)
            solarSystemIds && solarSystemIds.forEach(item => { url_ += "SolarSystemIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Pagination": paging !== undefined && paging !== null ? "" + paging : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSegments(_response);
        });
    }

    protected processGetSegments(response: Response): Promise<PagedListOfSegment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedListOfSegment.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedListOfSegment>(null as any);
    }
}

export class SolarSystemClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getSolarSystem(id: string): Promise<SolarSystem> {
        let url_ = this.baseUrl + "/api/SolarSystem/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSolarSystem(_response);
        });
    }

    protected processGetSolarSystem(response: Response): Promise<SolarSystem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SolarSystem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SolarSystem>(null as any);
    }

    getSolarSystems(nameContains: string | null | undefined, segmentId: string | null | undefined, entityIds: string[] | null | undefined, minimumEntityCount: number | null | undefined, maximumEntityCount: number | null | undefined, paging: SolarSystemPaging | null | undefined): Promise<PagedListOfSolarSystem> {
        let url_ = this.baseUrl + "/api/SolarSystem?";
        if (nameContains !== undefined && nameContains !== null)
            url_ += "NameContains=" + encodeURIComponent("" + nameContains) + "&";
        if (segmentId !== undefined && segmentId !== null)
            url_ += "SegmentId=" + encodeURIComponent("" + segmentId) + "&";
        if (entityIds !== undefined && entityIds !== null)
            entityIds && entityIds.forEach(item => { url_ += "EntityIds=" + encodeURIComponent("" + item) + "&"; });
        if (minimumEntityCount !== undefined && minimumEntityCount !== null)
            url_ += "MinimumEntityCount=" + encodeURIComponent("" + minimumEntityCount) + "&";
        if (maximumEntityCount !== undefined && maximumEntityCount !== null)
            url_ += "MaximumEntityCount=" + encodeURIComponent("" + maximumEntityCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Pagination": paging !== undefined && paging !== null ? "" + paging : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSolarSystems(_response);
        });
    }

    protected processGetSolarSystems(response: Response): Promise<PagedListOfSolarSystem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedListOfSolarSystem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedListOfSolarSystem>(null as any);
    }
}

export abstract class Entity implements IEntity {
    id?: string;
    name?: string | undefined;
    solarSystemId?: string;
    entityType?: EntityType;

    protected _discriminator: string;

    constructor(data?: IEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Entity";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.solarSystemId = _data["solarSystemId"];
            this.entityType = _data["entityType"];
        }
    }

    static fromJS(data: any): Entity {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "Planet") {
            let result = new Planet();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'Entity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        data["id"] = this.id;
        data["name"] = this.name;
        data["solarSystemId"] = this.solarSystemId;
        data["entityType"] = this.entityType;
        return data;
    }
}

export interface IEntity {
    id?: string;
    name?: string | undefined;
    solarSystemId?: string;
    entityType?: EntityType;
}

export enum EntityType {
    Planet = 0,
}

export class Planet extends Entity implements IPlanet {

    constructor(data?: IPlanet) {
        super(data);
        this._discriminator = "Planet";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): Planet {
        data = typeof data === 'object' ? data : {};
        let result = new Planet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPlanet extends IEntity {
}

export class PagedListOfEntity implements IPagedListOfEntity {
    pagingMetadata?: PagingMetadata;
    items?: Entity[];

    constructor(data?: IPagedListOfEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pagingMetadata = _data["pagingMetadata"] ? PagingMetadata.fromJS(_data["pagingMetadata"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Entity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedListOfEntity {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pagingMetadata"] = this.pagingMetadata ? this.pagingMetadata.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedListOfEntity {
    pagingMetadata?: PagingMetadata;
    items?: Entity[];
}

export class PagingMetadata implements IPagingMetadata {
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalItemCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;

    constructor(data?: IPagingMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalItemCount = _data["totalItemCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
        }
    }

    static fromJS(data: any): PagingMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new PagingMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalItemCount"] = this.totalItemCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        return data;
    }
}

export interface IPagingMetadata {
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalItemCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
}

export abstract class PagingBase implements IPagingBase {
    page?: number;
    pageSize?: number;
    sortOrder?: SortOrder;

    constructor(data?: IPagingBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): PagingBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PagingBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["sortOrder"] = this.sortOrder;
        return data;
    }
}

export interface IPagingBase {
    page?: number;
    pageSize?: number;
    sortOrder?: SortOrder;
}

export class EntityPaging extends PagingBase implements IEntityPaging {
    sortBy?: EntitySortBy;

    constructor(data?: IEntityPaging) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.sortBy = _data["sortBy"];
        }
    }

    static fromJS(data: any): EntityPaging {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPaging();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortBy"] = this.sortBy;
        super.toJSON(data);
        return data;
    }
}

export interface IEntityPaging extends IPagingBase {
    sortBy?: EntitySortBy;
}

export enum EntitySortBy {
    Name = 0,
    EntityType = 1,
}

export enum SortOrder {
    Ascending = 0,
    Descending = 1,
}

export class Galaxy implements IGalaxy {
    id?: string;
    name?: string;
    segments?: Segment[];

    constructor(data?: IGalaxy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["segments"])) {
                this.segments = [] as any;
                for (let item of _data["segments"])
                    this.segments!.push(Segment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Galaxy {
        data = typeof data === 'object' ? data : {};
        let result = new Galaxy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.segments)) {
            data["segments"] = [];
            for (let item of this.segments)
                data["segments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGalaxy {
    id?: string;
    name?: string;
    segments?: Segment[];
}

export class Segment implements ISegment {
    id?: string;
    name?: string;
    description?: string;
    solarSystems?: SolarSystem[];
    galaxyId?: string;
    indexX?: number;
    indexY?: number;
    indexZ?: number;

    constructor(data?: ISegment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["solarSystems"])) {
                this.solarSystems = [] as any;
                for (let item of _data["solarSystems"])
                    this.solarSystems!.push(SolarSystem.fromJS(item));
            }
            this.galaxyId = _data["galaxyId"];
            this.indexX = _data["indexX"];
            this.indexY = _data["indexY"];
            this.indexZ = _data["indexZ"];
        }
    }

    static fromJS(data: any): Segment {
        data = typeof data === 'object' ? data : {};
        let result = new Segment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.solarSystems)) {
            data["solarSystems"] = [];
            for (let item of this.solarSystems)
                data["solarSystems"].push(item.toJSON());
        }
        data["galaxyId"] = this.galaxyId;
        data["indexX"] = this.indexX;
        data["indexY"] = this.indexY;
        data["indexZ"] = this.indexZ;
        return data;
    }
}

export interface ISegment {
    id?: string;
    name?: string;
    description?: string;
    solarSystems?: SolarSystem[];
    galaxyId?: string;
    indexX?: number;
    indexY?: number;
    indexZ?: number;
}

export class SolarSystem implements ISolarSystem {
    id?: string;
    name?: string;
    entities?: Entity[];
    segmentId?: string;
    position?: Vector3;

    constructor(data?: ISolarSystem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["entities"])) {
                this.entities = [] as any;
                for (let item of _data["entities"])
                    this.entities!.push(Entity.fromJS(item));
            }
            this.segmentId = _data["segmentId"];
            this.position = _data["position"] ? Vector3.fromJS(_data["position"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SolarSystem {
        data = typeof data === 'object' ? data : {};
        let result = new SolarSystem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.entities)) {
            data["entities"] = [];
            for (let item of this.entities)
                data["entities"].push(item.toJSON());
        }
        data["segmentId"] = this.segmentId;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISolarSystem {
    id?: string;
    name?: string;
    entities?: Entity[];
    segmentId?: string;
    position?: Vector3;
}

export class Vector3 implements IVector3 {

    constructor(data?: IVector3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Vector3 {
        data = typeof data === 'object' ? data : {};
        let result = new Vector3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IVector3 {
}

export class PagedListOfSegment implements IPagedListOfSegment {
    pagingMetadata?: PagingMetadata;
    items?: Segment[];

    constructor(data?: IPagedListOfSegment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pagingMetadata = _data["pagingMetadata"] ? PagingMetadata.fromJS(_data["pagingMetadata"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Segment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedListOfSegment {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfSegment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pagingMetadata"] = this.pagingMetadata ? this.pagingMetadata.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedListOfSegment {
    pagingMetadata?: PagingMetadata;
    items?: Segment[];
}

export class SegmentPaging extends PagingBase implements ISegmentPaging {
    sortBy?: SegmentSortBy;

    constructor(data?: ISegmentPaging) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.sortBy = _data["sortBy"];
        }
    }

    static fromJS(data: any): SegmentPaging {
        data = typeof data === 'object' ? data : {};
        let result = new SegmentPaging();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortBy"] = this.sortBy;
        super.toJSON(data);
        return data;
    }
}

export interface ISegmentPaging extends IPagingBase {
    sortBy?: SegmentSortBy;
}

export enum SegmentSortBy {
    Name = 0,
    Description = 1,
}

export class PagedListOfSolarSystem implements IPagedListOfSolarSystem {
    pagingMetadata?: PagingMetadata;
    items?: SolarSystem[];

    constructor(data?: IPagedListOfSolarSystem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pagingMetadata = _data["pagingMetadata"] ? PagingMetadata.fromJS(_data["pagingMetadata"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SolarSystem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedListOfSolarSystem {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfSolarSystem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pagingMetadata"] = this.pagingMetadata ? this.pagingMetadata.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedListOfSolarSystem {
    pagingMetadata?: PagingMetadata;
    items?: SolarSystem[];
}

export class SolarSystemPaging extends PagingBase implements ISolarSystemPaging {
    sortBy?: SolarSystemSortBy;

    constructor(data?: ISolarSystemPaging) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.sortBy = _data["sortBy"];
        }
    }

    static fromJS(data: any): SolarSystemPaging {
        data = typeof data === 'object' ? data : {};
        let result = new SolarSystemPaging();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortBy"] = this.sortBy;
        super.toJSON(data);
        return data;
    }
}

export interface ISolarSystemPaging extends IPagingBase {
    sortBy?: SolarSystemSortBy;
}

export enum SolarSystemSortBy {
    Name = 0,
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}